/**
 * Backend API - Abstraction layer for ICP canisters
 *
 * Users see this as a normal API - they don't know it's calling ICP canisters.
 * All ICP implementation details are hidden behind these functions.
 */

import { Actor, HttpAgent, AnonymousIdentity } from "@dfinity/agent";
import { Principal } from "@dfinity/principal";

// Simple SHA-256 implementation for subscription ID generation
async function sha256(message: string): Promise<string> {
  const msgBuffer = new TextEncoder().encode(message);
  const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  return hashHex;
}

// Candid interface will be auto-generated by dfx
// For now, we define minimal types
interface CreateSubscriptionRequest {
  subscription_id: string;
  solana_contract_address: string;
  payment_token_mint: string;
  amount: bigint;
  subscriber_address: string;
  merchant_address: string;
  interval_seconds: bigint;
  start_time: [] | [bigint];
  api_key: string;
}

interface Subscription {
  id: string;
  solana_contract_address: string;
  subscriber_address: string;
  merchant_address: string;
  payment_token_mint: string;
  interval_seconds: bigint;
  next_execution: bigint;
  status: { Active: null } | { Paused: null } | { Cancelled: null } | { Expired: null };
  created_at: bigint;
  last_triggered: [] | [bigint];
  trigger_count: bigint;
  failed_payment_count: number;
  last_failure_time: [] | [bigint];
  last_error: [] | [string];
}

// Configuration - these will come from environment variables
const getConfig = () => {
  const timerCanisterId = import.meta.env.VITE_TIMER_CANISTER_ID || "";

  // Use IC mainnet if we have a mainnet canister ID (contains 'aaaag')
  const isMainnetCanister = timerCanisterId.includes('aaaag');
  const host = isMainnetCanister ? "https://ic0.app" : "http://localhost:4943";

  return {
    host,
    timerCanisterId,
    licenseCanisterId: import.meta.env.VITE_LICENSE_CANISTER_ID || "",
    solanaContractAddress: import.meta.env.VITE_SOLANA_CONTRACT || "",
    // USDC on Solana devnet (NOT mainnet)
    usdcMint: "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU",
    // Enterprise license for OuroC-Mesos
    apiKey: import.meta.env.VITE_ENTERPRISE_LICENSE_KEY || "ouro_enterprise_ouroc_mesos_2025",
  };
};

// Create agent (anonymous - no login required)
const createAgent = async () => {
  const config = getConfig();
  const agent = new HttpAgent({
    identity: new AnonymousIdentity(),
    host: config.host,
  });

  // Fetch root key for local development only (not for mainnet)
  if (config.host.includes('localhost')) {
    await agent.fetchRootKey().catch(err => {
      console.warn("Unable to fetch root key. Check if dfx is running:", err);
    });
  }

  return agent;
};

// IDL factory - will be replaced with auto-generated one
// This is a minimal version for the interface
const timerIdlFactory = ({ IDL }: any) => {
  const CreateSubscriptionRequest = IDL.Record({
    subscription_id: IDL.Text,
    solana_contract_address: IDL.Text,
    payment_token_mint: IDL.Text,
    amount: IDL.Nat64,
    subscriber_address: IDL.Text,
    merchant_address: IDL.Text,
    interval_seconds: IDL.Nat64,
    start_time: IDL.Opt(IDL.Nat64),
    api_key: IDL.Text,
  });

  const SubscriptionStatus = IDL.Variant({
    Active: IDL.Null,
    Paused: IDL.Null,
    Cancelled: IDL.Null,
    Expired: IDL.Null,
  });

  const Subscription = IDL.Record({
    id: IDL.Text,
    solana_contract_address: IDL.Text,
    subscriber_address: IDL.Text,
    merchant_address: IDL.Text,
    payment_token_mint: IDL.Text,
    interval_seconds: IDL.Nat64,
    next_execution: IDL.Nat64,
    status: SubscriptionStatus,
    created_at: IDL.Nat64,
    last_triggered: IDL.Opt(IDL.Nat64),
    trigger_count: IDL.Nat64,
    failed_payment_count: IDL.Nat32,
    last_failure_time: IDL.Opt(IDL.Nat64),
    last_error: IDL.Opt(IDL.Text),
  });

  return IDL.Service({
    create_subscription: IDL.Func([CreateSubscriptionRequest], [IDL.Variant({ Ok: IDL.Text, Err: IDL.Text })], []),
    list_subscriptions: IDL.Func([], [IDL.Vec(Subscription)], ["query"]),
    pause_subscription: IDL.Func([IDL.Text], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    resume_subscription: IDL.Func([IDL.Text], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    cancel_subscription: IDL.Func([IDL.Text], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    generate_payment_signature: IDL.Func(
      [IDL.Text, IDL.Nat64],
      [IDL.Variant({ Ok: IDL.Tuple(IDL.Vec(IDL.Nat8), IDL.Int64), Err: IDL.Text })],
      []
    ),
  });
};

// Get timer actor
let timerActorInstance: any = null;

const getTimerActor = async () => {
  if (timerActorInstance) return timerActorInstance;

  const agent = await createAgent();
  const config = getConfig();

  timerActorInstance = Actor.createActor(timerIdlFactory, {
    agent,
    canisterId: config.timerCanisterId,
  });

  return timerActorInstance;
};

// Generate unique deterministic subscription ID using hash
const generateSubscriptionId = async (
  walletAddress: string,
  merchantAddress: string,
  amount: number
): Promise<string> => {
  const timestamp = Date.now();
  const nonce = Math.random().toString(36).substring(2, 15);
  const data = `${walletAddress}:${merchantAddress}:${amount}:${timestamp}:${nonce}`;
  const hash = await sha256(data);
  return hash.slice(0, 32); // 32-character hex ID
};

/**
 * Create a new subscription (one-time or recurring)
 *
 * @param walletAddress - User's Solana wallet address (from Phantom)
 * @param merchantAddress - Merchant's Solana wallet address (or escrow PDA)
 * @param amountUsdc - Amount in USDC (e.g., 9.99 for $9.99)
 * @param intervalSeconds - Payment interval in seconds (0 for one-time purchase)
 * @param merchantName - Merchant's business name for display
 * @returns Subscription ID if successful
 */
export async function createSubscription(
  walletAddress: string,
  merchantAddress: string,
  amountUsdc: number,
  intervalSeconds: number,
  merchantName: string = "OuroC Merchant"
): Promise<{ success: boolean; subscriptionId?: string; error?: string; isRecurring?: boolean }> {
  try {
    const config = getConfig();

    // Generate unique subscription ID
    const subscriptionId = await generateSubscriptionId(walletAddress, merchantAddress, amountUsdc);

    // Determine if this is recurring or one-time
    const isRecurring = intervalSeconds > 0;

    // Calculate reminder days (only for intervals > 1 day)
    const reminderDays = intervalSeconds > 86400 ? 1 : 0;

    // TODO: Call Solana smart contract first
    // This will be implemented when we deploy the Solana contract
    console.log('üìù Would call Solana contract create_subscription with:', {
      subscriptionId,
      amount: Math.floor(amountUsdc * 1_000_000), // USDC in micro-units
      intervalSeconds: isRecurring ? intervalSeconds : -1, // -1 for one-time, positive for recurring
      merchantAddress,
      merchantName,
      paymentTokenMint: config.usdcMint, // USDC mint address on Solana
    });

    // Note: Frontend will call:
    // 1. For RECURRING: approve_subscription_delegate() first (user approves token delegation)
    // 2. Then: create_subscription() to register on-chain
    // 3. ICP timer handles notifications automatically (1 day before if interval > 1 day)

    // Only create timer canister subscription if recurring
    if (isRecurring) {
      const actor = await getTimerActor();

      const request: CreateSubscriptionRequest = {
        subscription_id: subscriptionId,
        solana_contract_address: config.solanaContractAddress,
        payment_token_mint: config.usdcMint,
        amount: BigInt(Math.floor(amountUsdc * 1_000_000)),
        subscriber_address: walletAddress,
        merchant_address: merchantAddress,
        interval_seconds: BigInt(intervalSeconds),
        start_time: [], // Start immediately
        api_key: config.apiKey,
      };

      const result = await actor.create_subscription(request);

      if ("Ok" in result) {
        console.log(`‚úÖ Timer canister subscription created: ${result.Ok}`);
        console.log(`üîî Notifications: ${reminderDays > 0 ? 'Enabled (1 day before payment)' : 'Disabled'}`);

        return {
          success: true,
          subscriptionId: result.Ok,
          isRecurring: true,
        };
      } else {
        return {
          success: false,
          error: result.Err,
        };
      }
    } else {
      // One-time purchase - no timer needed
      console.log(`‚úÖ One-time purchase created: ${subscriptionId}`);
      console.log(`‚è≠Ô∏è Skipped timer canister (one-time purchase)`);

      return {
        success: true,
        subscriptionId,
        isRecurring: false,
      };
    }
  } catch (error) {
    console.error("Failed to create subscription:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}

/**
 * List all subscriptions for a wallet
 *
 * @param walletAddress - User's Solana wallet address
 * @returns Array of subscriptions
 */
export async function listSubscriptions(walletAddress: string): Promise<Subscription[]> {
  try {
    const actor = await getTimerActor();
    const allSubscriptions = await actor.list_subscriptions();

    // Filter by wallet address (backend should do this, but we filter client-side for now)
    return allSubscriptions.filter((sub: Subscription) =>
      sub.subscriber_address === walletAddress
    );
  } catch (error) {
    console.error("Failed to list subscriptions:", error);
    return [];
  }
}

/**
 * Pause a subscription
 *
 * @param subscriptionId - Subscription ID to pause
 */
export async function pauseSubscription(subscriptionId: string): Promise<{ success: boolean; error?: string }> {
  try {
    const actor = await getTimerActor();
    const result = await actor.pause_subscription(subscriptionId);

    if ("Ok" in result) {
      return { success: true };
    } else {
      return { success: false, error: result.Err };
    }
  } catch (error) {
    console.error("Failed to pause subscription:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}

/**
 * Resume a paused subscription
 *
 * @param subscriptionId - Subscription ID to resume
 */
export async function resumeSubscription(subscriptionId: string): Promise<{ success: boolean; error?: string }> {
  try {
    const actor = await getTimerActor();
    const result = await actor.resume_subscription(subscriptionId);

    if ("Ok" in result) {
      return { success: true };
    } else {
      return { success: false, error: result.Err };
    }
  } catch (error) {
    console.error("Failed to resume subscription:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}

/**
 * Cancel a subscription permanently
 *
 * @param subscriptionId - Subscription ID to cancel
 */
export async function cancelSubscription(subscriptionId: string): Promise<{ success: boolean; error?: string }> {
  try {
    const actor = await getTimerActor();
    const result = await actor.cancel_subscription(subscriptionId);

    if ("Ok" in result) {
      return { success: true };
    } else {
      return { success: false, error: result.Err };
    }
  } catch (error) {
    console.error("Failed to cancel subscription:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}

/**
 * Generate payment signature from ICP canister
 *
 * @param subscriptionId - Subscription ID to sign for
 * @param amount - Amount in micro-USDC (e.g., 1000000 = 1 USDC)
 * @returns Signature bytes and timestamp if successful
 */
export async function getPaymentSignature(
  subscriptionId: string,
  amount: number
): Promise<{ success: boolean; signature?: number[]; timestamp?: bigint; error?: string }> {
  try {
    const actor = await getTimerActor();
    const result = await actor.generate_payment_signature(subscriptionId, BigInt(amount));

    if ("Ok" in result) {
      const [signature, timestamp] = result.Ok;
      console.log(`‚úÖ ICP signature generated for ${subscriptionId}`);
      console.log(`   Signature: ${signature.length} bytes`);
      console.log(`   Timestamp: ${timestamp}`);

      return {
        success: true,
        signature: signature,
        timestamp: timestamp,
      };
    } else {
      return {
        success: false,
        error: result.Err,
      };
    }
  } catch (error) {
    console.error("Failed to generate payment signature:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}

/**
 * Health check - ping the backend
 *
 * @returns true if backend is responding
 */
export async function pingBackend(): Promise<boolean> {
  try {
    const actor = await getTimerActor();
    // Assuming there's a ping method - adjust based on actual interface
    await actor.list_subscriptions();
    return true;
  } catch (error) {
    console.error("Backend health check failed:", error);
    return false;
  }
}
